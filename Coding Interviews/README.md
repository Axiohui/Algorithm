# 剑指offer思路总结

## 面试题3 二维数组中查找

先选右上角一次向左下移动

## 面试题4 替换空格

思路：先遍历一遍统计字符串长度并且统计空格个数，然后增添相对应的格式，从后向前将空格移动。

## 面试题5 从末到头打印链表

思路一：利用递归遍历链表，最后打印。

思路二：利用栈实现。

## 面试题6 重建二叉树
题目：

    给定二叉树的前序遍历和中序遍历的结果，重建该二叉树。例如给定前序遍历为{1,2,4,7,3,5,6,8},中序遍历序列为{4,7,2,1,5,3,8,6}.

思路：

根据先序中序遍历的特点可知，对于先序遍历，其第一个访问的为根节点因此根节点为1，而对于中序遍历而言，先左子树然后是根节点，最后是右子树。因此{4,7,2}为左子树，{5,4,8,6}为右子树。对应于先序{2,4,7},{3,5,6,8}，一次可以类推,2为左子树的根节点，3为右子树的根节点，最后递归求解就能够得到整棵树。

## 面试题7 用两个栈实现队列

思路：

很简单，利用两个栈，先将数据压入其中一个栈，然后将数据一次弹出来压入另外一个栈。这样原来在栈底的数据在另一个栈中就变到了栈顶的位置。但是需要注意的是如果弹出的栈不为空，就不能再往弹出栈添加元素。

## 面试题8 旋转数组的最小数字



## 面试题9 斐波那契数列

斐波拉契数列

## 面试题56 链表中环的入口结点

思路：首先判断是否含有环，然后根据根据相关公式计算出入口节点。

具体做法首先设置两个指针，一个快指针和一个慢指针。快指针的速度为慢指针的速度的两倍，因此当他们能够相遇时，则存在入口节点，如果不能相遇，则不存在环。如果存在，则有下面的关系式。当找到相遇结点的时候，再将快速指针放到头结点，当两个同时再次相遇的时候，则会在环的入口处相遇。[推导过程](https://blog.csdn.net/snow_7/article/details/52181049)



## 面试题58 二叉树下的一个结点

思路：
- 如果结点有右子树，那么下一个结点则是右子树中最左子树结点。
- 如果没有右子树，结点是它的父节点的左子节点，那么父节点则为下一个结点。
- 如果结点既没有右子树，同时它还是父节点的右子节点，那么一直沿着父节点向上遍历，直到找到一个是它父节点的左子节点。


## 面试题59 对称的二叉树

思路：对于对称二叉树而言，其原始二叉树和对称转换之后的二叉树的先序遍历顺序是一样的。因此采用先序遍历，先遍历左子树在遍历右子树得到的序列和先遍历左子树在遍历右子树得到的序列是一样的。

## 面试题60 按行打印二叉树

思路：
按行打印二叉树需要利用队列先进先出的特点然后设置两个辅助变量，toBePrinted记录当前没有被打印的结点，nextLevel记录下一层需要打印的结点。首先将toBePrinted设置成1，nextLevel记录下来，然后判断父节点的叶子节点是否为空，不为空将其加入队列中，然后nextLevel+1。当该层需要打印的结点为0时，然后令toBePrinted=nextLevel，并且将nextLevel置为0。然后继续上述操作。

## 面试题61 按之字形顺序打印二叉树

之字形：和前面一题相似，按层输出二叉树，但是区别在于和正常的按层输出，奇数层是按照正序输出，偶数层是按照逆序输出。

思路：设计两个栈，奇数层的栈和偶数层的栈。首先将第一层节点压入奇数栈，然后将其弹出打印，并且按照左子节点右子节点的顺序将其子节点压入偶数栈，直到栈为空后换行。然后从偶数栈中依次弹出，并且将弹出的子节点按照右子节点和左子节点压入奇数栈。重复上面操作，直到所有站为空。

## 面试题62 

